---
title: "Исследование информации о состоянии беспроводных сетей"
subtitle: "Практическая #5"
author: "QazRT"
format: 
  md:
    output-file: README.md
---

## Цель работы

1.  Получить знания о методах исследования радиоэлектронной обстановки.
2.  Составить представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3.  Закрепить практические навыки использования языка программирования R для обработки данных
4.  Закрепить знания основных функций обработки данных экосистемы tidyverse языка R

## Исходные данные

1.  Программное обеспечение Windows 10 Pro
2.  Visual Studio Code с установленными плагинами для работы с языком R
3.  Интерпретатор языка R 4.5.1

## План:

1.  Загрузить данные и провести действи для приведения в "аккуратный" вид
2.  Определить небезопасные точки доступа
3.  Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах
4.  Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.
5.  Обнаружить топ-10 самых быстрых точек доступа.
6.  Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.
7.  Определить производителя для каждого обнаруженного устройства
8.  Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес
9.  Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.
10. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.

## Шаги:

0.  Импорт библиотек

```{r}
library(tidyverse)
library(lubridate)
```

1.  Чтение и разделение данных

    ```{r}
    lines <- read_lines("P2_wifi_data.csv")
    split_idx <- which(lines == "")[1]

    ap_lines <- lines[3:(split_idx-1)]
    ap_data <- read_csv(paste(ap_lines, collapse = "\n"),
      col_names = c("BSSID", "First_time_seen", "Last_time_seen", "channel", "Speed", 
                    "Privacy", "Cipher", "Authentication", "Power", "#beacons", "#IV", 
                    "LAN_IP", "ID_length", "ESSID", "Key"),
      na = c("", " ", "(not associated)")
    )

    sta_lines <- lines[(split_idx+2):length(lines)]
    sta_data <- read_csv(paste(sta_lines, collapse = "\n"),
      col_names = c("Station_MAC", "First_time_seen", "Last_time_seen", 
                    "Power", "Packets", "BSSID", "Probed_ESSIDs"),
      na = c("", " ", "(not associated)")
    )
    ```

2.  Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в соответствии с типом данных

    ```{r}
    ap_data
    sta_data
    ap_data_clean <- ap_data %>% mutate(
      BSSID = as.character(BSSID),
      First_time_seen = ymd_hms(First_time_seen),
      Last_time_seen = ymd_hms(Last_time_seen),
      channel = as.integer(channel),
      Speed = as.integer(Speed),
      Privacy = as.character(Privacy),
      Cipher = as.character(Cipher),
      Authentication = as.character(Authentication),
      Power = as.integer(Power),
      Beacons = as.integer(`#beacons`),
      IV = as.integer(`#IV`),
      LAN_IP = as.character(LAN_IP),
      ID_length = as.integer(ID_length),
      ESSID = as.character(ESSID)
    )

    sta_data_clean <- sta_data %>% mutate(
      Station_MAC = as.character(Station_MAC),
      First_time_seen = ymd_hms(First_time_seen),
      Last_time_seen = ymd_hms(Last_time_seen),
      Power = as.integer(Power),
      Packets = as.integer(Packets),
      BSSID = as.character(BSSID),
      Probed_ESSIDs = as.character(Probed_ESSIDs)
    )
    ```

3.  Определить небезопасные точки доступа (без шифрования – OPN)

    ```{r}
    insecure_aps <- ap_data_clean %>% filter(Privacy == "OPN" | is.na(Privacy))
    insecure_aps 
    ```

4.  Определить производителя для каждого обнаруженного устройства

    ```{r}
    extract_oui <- function(mac_vec) {
      mac_clean <- gsub("[:.-]", "", toupper(mac_vec))
      oui <- ifelse(!is.na(mac_clean) & nchar(mac_clean) >= 6, substr(mac_clean, 1, 6), NA_character_)
      return(oui)
    }

    oui_url <- "https://gitlab.com/wireshark/wireshark/-/raw/release-4.0/manuf"
    oui_raw <- readLines(oui_url)
    oui_clean <- oui_raw[str_detect(oui_raw, regex("^[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}", ignore_case = TRUE))]
    oui_df <- tibble(line = oui_clean) %>%
      separate(line, into = c("OUI", "ShortName", "FullName"), sep = "\t", extra = "merge") %>%
      mutate(OUI = toupper(gsub(":", "", OUI))) %>% filter(str_length(OUI) == 6)

    ap_data_clean <- ap_data_clean %>% mutate(OUI = extract_oui(BSSID))
    sta_data_clean <- sta_data_clean %>% mutate(OUI = extract_oui(Station_MAC))

    ap_with_vendor <- ap_data_clean %>% left_join(oui_df, by = "OUI")
    sta_with_vendor <- sta_data_clean %>% left_join(oui_df, by = "OUI")
    ```

5.  Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

    ```{r}
    wpa3_aps <- ap_data_clean %>% filter(str_detect(Privacy, regex("WPA3", ignore_case = TRUE)))
    wpa3_aps
    ```

6.  Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.

    ```{r}
    ap_data_clean <- ap_data_clean %>% mutate(Duration_sec = as.numeric(difftime(Last_time_seen, First_time_seen, units = "secs"))) %>% arrange(desc(Duration_sec))
    ```

7.  Обнаружить топ-10 самых быстрых точек доступа.

    ```{r}
    top_speed_aps <- ap_data_clean %>% arrange(desc(Speed)) %>% head(10)
    top_speed_aps
    ```

8.  Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.

    ```{r}
    beacon_rate <- ap_data_clean %>% mutate(Duration_min = Duration_sec / 60, Beacons_per_min = Beacons / pmax(Duration_min, 1)) %>% arrange(desc(Beacons_per_min))
    beacon_rate
    ```

9.  Определить производителя для каждого обнаруженного устройства

    ```{r}
    sta_with_vendor
    ```

10. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес

    ```{r}
    is_global_mac <- function(mac_vec) {
      mac_clean <- gsub("[:.-]", "", toupper(mac_vec))
      first_byte_hex <- substr(mac_clean, 1, 2)
      first_byte_dec <- suppressWarnings(strtoi(first_byte_hex, base = 16))
      is_global <- (first_byte_dec & 2) == 0
      is_global[is.na(is_global)] <- FALSE
      return(is_global)
    }

    sta_data_clean <- sta_data_clean %>% mutate(is_global = is_global_mac(Station_MAC))

    non_randomized_clients <- sta_data_clean %>% group_by(Station_MAC) %>% summarise(
      probed_networks = n_distinct(Probed_ESSIDs[Probed_ESSIDs != "Not Probing"], na.rm = TRUE),
      observation_count = n(),
      first_seen = min(First_time_seen),
      last_seen = max(Last_time_seen),
      total_packets = sum(Packets, na.rm = TRUE),
      .groups = "drop"
    ) %>% filter(probed_networks > 1 | observation_count > 5) %>% arrange(desc(probed_networks), desc(observation_count))

    non_randomized_clients
    ```

11. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

    ```{r}
    sta_clusters <- sta_data_clean %>% filter(BSSID != "(not associated)" & !is.na(Probed_ESSIDs) & Probed_ESSIDs != "") %>% group_by(BSSID, Probed_ESSIDs) %>% summarise(
      mean_power = mean(Power, na.rm = TRUE),
      sd_power = sd(Power, na.rm = TRUE),
      n = n(),
      first_seen = min(First_time_seen),
      last_seen = max(Last_time_seen),
      .groups = "drop"
    ) %>% arrange(sd_power)

    sta_clusters
    ```

12. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.

    ```{r}
    sta_clusters <- sta_clusters %>% mutate(signal_stability = 1 / (sd_power + 1e-6))
    most_stable_cluster <- sta_clusters %>% arrange(desc(signal_stability)) %>% slice(1)
    most_stable_cluster
    ```

## Оценка результата

В результате лабораторной работы мы получили и закрепили знания о методах исследования радиоэлектронной обстановки

## Вывод

Таким образом, мы научились, используя программный пакет tidyverse, анализировать сетевые дампы с помощью языка программирования R